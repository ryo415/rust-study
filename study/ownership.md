# 所有権
- 変数束縛は所有権を持つ
- これはスコープから外れる時束縛されているリソースを開放することを意味する
```
fn foo() {
  let v = vec![1, 2, 3];
}
```
- foo()の最後でvがスコープから外れる時vに割り当てられたVec<T>の全てを取り除く
## ムーブセマンティクス
- Rustは与えられたリソースに対する束縛が一つだけあるということを保証する
- 下の例だとベクタオブジェクトはスタックに保存され、ヒープに[1, 2, 3]へのポインタが保存される。そこでv2も宣言するとスタックへのポインタが2つ作られ、Rustの安全性保証に違反する
```
fn main() {
  let v = vec![1, 2, 3];

  let v2 = v;

  println!("v[0] is: {}", v[0]);
}
```
- これはvの中身の所有権がv2へ移っているためエラーとなる
- 所有権を受け取る関数を定義し、引数として渡した場合も同じようなことが起こる
```
fn take(v: Vec<i32>) {
    // ここで何が起きるかは重要ではない
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```
## Copy型
- 他の束縛に所有権が転送されると元の束縛は使えなくなる
- しかしCopyと呼ばれるトレイトにより、コピーが作られるものがある
```
fn main() {
  let v = 1;

  let v2 = v;

  println!("v is: {}", v);
}
```
- この場合vはi32でCopyが実装されている
- vをv2に割り当てる時にデータのコピーが作られ、あとでまだvを使うことができる
- これはi32がポインタを持たず、完全コピーだからである
- i32型とbool型はCopyトレイトを実装している

## 所有権を超えて
- 書いた関数全てで所有権を返さなければならない場合以下になる
```
fn foo(v: Vec<i32>) -> Vec<i32> {
  // vについての作業を行う

  // 所有権を返す
  v
}
```
- 多くの所有権を受け取るともっと複雑になる
```
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
  // v1とv2についての作業を行う

  // 所有権と関数の結果を返す
  (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```
- こういった場合、借用という機能が手助けしてくれる
