# 借用と参照
- 借用を使うと全ての関数に束縛を渡す際、いちいち全ての所有権を返さなくてよくなる
- 借用には&T参照と&mut T参照がある
- ルールとして以下の二つは同時に持つことができない
  - リソースに対する一つ以上の参照(&T)
  - ただ一つのミュータブルな参照(&mut T)
## 借用
```
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // v1とv2についての作業を行う

    // 答えを返す
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);
```
- Vec<i32>ではなく&Vec<i32>を使う
- 束縛に&をつけて渡す
- そうすることでfoo()のスコープから外れた時再度束縛を使うことができる

## &mut参照
```
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```
- &mutをつけて渡すことでミュータブルな参照とできる
- また、受け取る側にアスタリスクをつける必要がある
- ルールとしてミュータブルな参照を一つ持つと他の借用が使えないため、使用場所では{}でスコープをつける必要がある
## ルール
```
let mut x = 5;
let y = &mut x;

*y += 1;

println!("{}", x);
```
- このコードでエラーになる原因
  - yはミュータブルな参照を持つ
  - println!はxの&T参照をしようとする
  - その際に&T参照と&mut T参照を同時に持つことになりルール違反となる
## 解放後の使用
```
let y: &i32;
{
    let x = 5;
    y = &x;
}

println!("{}", y);
```
- これはyの参照先であるxがスコープから外れているためエラーとなる
```
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);
```
- 借用はする側よりされる側の方が長く生存しなければならない
- 上の例だとyは借用する側だがされる側のxより前に宣言されているためエラーとなる
- 生存関係はライフスタイルの章を参照

## 注意点
- ~~&はCのポインタと混同するが、Rustの場合、借用であるという記号でしかない~~
- と思ったら普通にポインタっぽい。詳しくは後ほど勉強する
- 最初に束縛をミュータブルで宣言しても&T参照で借用したスコープ内ではイミュータブルとなる

